{"ast":null,"code":"import { base_url } from \"../../constants\";\nexport const GET_PRODUCTS = 'GET_PRODUCTS';\nexport const GET_PRODUCT_CATEGORIES = 'GET_PRODUCT_CATEGORIES';\nexport const getProducts = (categorySlug = '', filter) => {\n  return async dispatch => {\n    try {\n      categorySlug = categorySlug == 'all' ? '' : categorySlug;\n      let query = '';\n\n      if (filter) {\n        query = '?filter=1&';\n\n        for (let prop in filter) {\n          query += \"\".concat(prop, \"=\").concat(filter[prop], \"&\");\n        }\n\n        query = query.substring(0, query.length - 1);\n      }\n\n      const response = await fetch(\"\".concat(base_url, \"/products/\").concat(categorySlug).concat(query));\n      const jsonResponse = await response.json();\n\n      if (response.status == 200) {\n        dispatch({\n          type: GET_PRODUCTS,\n          products: jsonResponse.message\n        });\n      }\n\n      return jsonResponse;\n    } catch (error) {\n      console.log(error);\n    }\n  };\n};\nexport const getCategories = () => {\n  return dispatch => {\n    fetch(\"\".concat(base_url, \"/category\"), {\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    }).then(response => response.json()).then(jsonResponse => {\n      dispatch({\n        type: GET_PRODUCT_CATEGORIES,\n        categories: jsonResponse.message\n      });\n    }).catch(error => {\n      console.log(error);\n    });\n  };\n};\nexport const getSingleProduct = productSlug => {\n  return async dispatch => {\n    try {\n      const response = await fetch(\"\".concat(base_url, \"/products/category/\").concat(productSlug));\n      const jsonResponse = await response.json();\n\n      if (response.status === 200) {}\n    } catch (error) {\n      console.log(error);\n    }\n  };\n};","map":{"version":3,"sources":["/Users/Amina/Desktop/FoodApp/foodstore-front-end/src/store/actions/productActions.js"],"names":["base_url","GET_PRODUCTS","GET_PRODUCT_CATEGORIES","getProducts","categorySlug","filter","dispatch","query","prop","substring","length","response","fetch","jsonResponse","json","status","type","products","message","error","console","log","getCategories","headers","then","categories","catch","getSingleProduct","productSlug"],"mappings":"AAAA,SAASA,QAAT,QAAyB,iBAAzB;AAEA,OAAO,MAAMC,YAAY,GAAG,cAArB;AACP,OAAO,MAAMC,sBAAsB,GAAG,wBAA/B;AAEP,OAAO,MAAMC,WAAW,GAAG,CAACC,YAAY,GAAG,EAAhB,EAAoBC,MAApB,KAA+B;AACtD,SAAO,MAAMC,QAAN,IAAkB;AAErB,QAAG;AAECF,MAAAA,YAAY,GAAIA,YAAY,IAAI,KAAjB,GAA0B,EAA1B,GAA+BA,YAA9C;AAEA,UAAIG,KAAK,GAAG,EAAZ;;AACA,UAAGF,MAAH,EAAU;AACNE,QAAAA,KAAK,GAAG,YAAR;;AACA,aAAI,IAAIC,IAAR,IAAgBH,MAAhB,EAAuB;AACnBE,UAAAA,KAAK,cAAOC,IAAP,cAAeH,MAAM,CAACG,IAAD,CAArB,MAAL;AACH;;AACDD,QAAAA,KAAK,GAAGA,KAAK,CAACE,SAAN,CAAgB,CAAhB,EAAmBF,KAAK,CAACG,MAAN,GAAa,CAAhC,CAAR;AACH;;AAED,YAAMC,QAAQ,GAAG,MAAMC,KAAK,WAAIZ,QAAJ,uBAAyBI,YAAzB,SAAwCG,KAAxC,EAA5B;AACA,YAAMM,YAAY,GAAG,MAAMF,QAAQ,CAACG,IAAT,EAA3B;;AACA,UAAGH,QAAQ,CAACI,MAAT,IAAmB,GAAtB,EAA0B;AACtBT,QAAAA,QAAQ,CAAC;AACLU,UAAAA,IAAI,EAAEf,YADD;AAELgB,UAAAA,QAAQ,EAAEJ,YAAY,CAACK;AAFlB,SAAD,CAAR;AAIH;;AAED,aAAOL,YAAP;AAEH,KAxBD,CAwBC,OAAMM,KAAN,EAAY;AACTC,MAAAA,OAAO,CAACC,GAAR,CAAYF,KAAZ;AACH;AAEJ,GA9BD;AA+BH,CAhCM;AAkCP,OAAO,MAAMG,aAAa,GAAG,MAAM;AAC/B,SAAOhB,QAAQ,IAAI;AACfM,IAAAA,KAAK,WAAIZ,QAAJ,gBAAyB;AAC1BuB,MAAAA,OAAO,EAAE;AACL,wBAAiB;AADZ;AADiB,KAAzB,CAAL,CAKCC,IALD,CAKMb,QAAQ,IAAIA,QAAQ,CAACG,IAAT,EALlB,EAMCU,IAND,CAMMX,YAAY,IAAI;AAClBP,MAAAA,QAAQ,CAAC;AACLU,QAAAA,IAAI,EAAEd,sBADD;AAELuB,QAAAA,UAAU,EAAEZ,YAAY,CAACK;AAFpB,OAAD,CAAR;AAIH,KAXD,EAYCQ,KAZD,CAYOP,KAAK,IAAI;AACZC,MAAAA,OAAO,CAACC,GAAR,CAAYF,KAAZ;AACH,KAdD;AAeH,GAhBD;AAiBH,CAlBM;AAoBP,OAAO,MAAMQ,gBAAgB,GAAIC,WAAD,IAAiB;AAC7C,SAAO,MAAMtB,QAAN,IAAkB;AACrB,QAAG;AAEC,YAAMK,QAAQ,GAAG,MAAMC,KAAK,WAAIZ,QAAJ,gCAAkC4B,WAAlC,EAA5B;AACA,YAAMf,YAAY,GAAG,MAAMF,QAAQ,CAACG,IAAT,EAA3B;;AACA,UAAGH,QAAQ,CAACI,MAAT,KAAoB,GAAvB,EAA2B,CAI1B;AAGJ,KAXD,CAWC,OAAMI,KAAN,EAAY;AACTC,MAAAA,OAAO,CAACC,GAAR,CAAYF,KAAZ;AACH;AACJ,GAfD;AAgBH,CAjBM","sourcesContent":["import { base_url } from \"../../constants\";\n\nexport const GET_PRODUCTS = 'GET_PRODUCTS';\nexport const GET_PRODUCT_CATEGORIES = 'GET_PRODUCT_CATEGORIES';\n\nexport const getProducts = (categorySlug = '', filter) => {\n    return async dispatch => {\n\n        try{\n\n            categorySlug = (categorySlug == 'all') ? '' : categorySlug;\n\n            let query = '';\n            if(filter){\n                query = '?filter=1&'\n                for(let prop in filter){\n                    query += `${prop}=${filter[prop]}&`\n                }\n                query = query.substring(0, query.length-1);\n            }\n\n            const response = await fetch(`${base_url}/products/${categorySlug}${query}`);\n            const jsonResponse = await response.json();\n            if(response.status == 200){\n                dispatch({\n                    type: GET_PRODUCTS,\n                    products: jsonResponse.message\n                });\n            }\n\n            return jsonResponse;\n\n        }catch(error){\n            console.log(error);\n        }\n\n    }\n}\n\nexport const getCategories = () => {\n    return dispatch => {\n        fetch(`${base_url}/category`, {\n            headers: {\n                'Content-Type' : 'application/json'\n            }\n        })\n        .then(response => response.json())\n        .then(jsonResponse => {\n            dispatch({\n                type: GET_PRODUCT_CATEGORIES,\n                categories: jsonResponse.message\n            });\n        })\n        .catch(error => {\n            console.log(error);\n        });\n    }\n}\n\nexport const getSingleProduct = (productSlug) => {\n    return async dispatch => {\n        try{\n\n            const response = await fetch(`${base_url}/products/category/${productSlug}`);\n            const jsonResponse = await response.json();\n            if(response.status === 200){\n\n               \n\n            }\n\n\n        }catch(error){\n            console.log(error);\n        }\n    }\n}\n\n"]},"metadata":{},"sourceType":"module"}